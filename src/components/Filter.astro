---
const { tags } = Astro.props;
---

<div class="filters">
  <form id="searchForm" class="search-form">
    <div class="search-wrapper">
      <input
        type="search"
        id="searchInput"
        placeholder="Buscar por palabra clave"
        class="search-input"
      />
      <button
        type="button"
        class="clear-search"
        id="clearSearch"
        style="display: none;"
      >
        ✕
      </button>
    </div>
  </form>

  <div class="tags-filter">
    <button class="tag-btn active" data-tag="all">Todas</button>
    {
      tags.map((tag: string) => (
        <button class="tag-btn" data-tag={tag}>
          {tag}
        </button>
      ))
    }
  </div>
</div>

<div class="no-results" style="display: none;">
  <p>
    No se encontraron resultados que coincidan con tus criterios de búsqueda.
  </p>
  <button class="reset-search-btn">Limpiar búsqueda</button>
</div>

<style is:inline>
    .filters {
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 1em;
    }

    .search-wrapper {
        position: relative;
        width: 100%;
    }

    .search-input {
        width: 100%;
        padding: 0.5em 1em 0.5em 0.5em;
        border-radius: 4px;
        background-color: var(--background-color);
        color: var(--foreground-color);
        border: 1px solid var(--border-color);
        font-size: 0.75em;
    }

    .tags-filter {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5em;
    }

    .tag-btn {
        padding: 0.25em 0.25em;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background: var(--background-color);
        color: var(--foreground-color);
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .tag-btn.active {
        background: var(--accent-color);
        color: var(--foreground-color);
    }

    @keyframes highlightFade {
        from {
            background-color: var(--accent-color);
        }
        to {
            background-color: var(--accent-color-muted);
        }
    }

    .tag-btn:hover {
        background: var(--accent-color);
        color: var(--background-color);
    }

    .tag-btn.active {
        background: var(--accent-color);
        color: var(--background-color);
        border-color: var(--accent-color);
    }

    .no-results {
        text-align: center;
        padding: 2em;
        border-radius: 0.5em;
        margin: 2em 0;
    }

    .no-results p {
        color: var(--accent-color-muted);
        margin-bottom: 1em;
    }

    .reset-search-btn {
        padding: 0.5em 1em;
        background: transparent;
        border-radius: 0.5em;
        cursor: pointer;
        font-size: 0.875em;
        transition: all 0.3s ease;
    }

    .reset-search-btn:hover {
        color: var(--accent-color);
    }

    .clear-search {
        position: absolute;
        right: 0.5em;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        padding: 0.25em 0.5em;
        cursor: pointer;
        transition: all 0.2s ease;
        color: var(--accent-color-muted);
    }

    .clear-search:hover {
        color: var(--accent-color);
    }
</style>

<script>
  const searchInput = document.getElementById(
    "searchInput"
  ) as HTMLInputElement;
  const tagButtons = document.querySelectorAll(".tag-btn");
  const educationItems = document.querySelectorAll(".timeline-item");
  const noResultsDiv = document.querySelector(".no-results") as HTMLElement;
  const resetSearchButton = document.querySelector(".reset-search-btn");
  const clearSearchBtn = document.getElementById("clearSearch");

  let activeTag = "all";
  let searchTerm = "";

  // Function to normalize text (remove accents and convert to lowercase)
  function normalizeText(text: string): string {
    return text
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "") // Remove accents
      .toLowerCase()
      .trim();
  }

  function highlightText(element: Element, term: string) {
    if (!term.trim()) {
      // Restore original text by removing highlight spans
      element.innerHTML = element.innerHTML.replace(
        /<mark class="highlight">|<\/mark>/g,
        ""
      );
      return;
    }

    const originalText = element.innerHTML.replace(
      /<mark class="highlight">|<\/mark>/g,
      ""
    );

    // Create a regex pattern that matches the normalized version of the search term
    const normalizedTerm = normalizeText(term);

    // Use a regex pattern that matches accented and non-accented characters
    const accentInsensitivePattern = normalizedTerm
      .split("")
      .map((char) => {
        const accentedVariants: Record<string, string> = {
          a: "[aáà]",
          e: "[eéè]",
          i: "[iíì]",
          o: "[oóò]",
          u: "[uúù]",
          n: "[nñ]"
        };
        return accentedVariants[char] || char;
      })
      .join("");

    const regex = new RegExp(`(${accentInsensitivePattern})`, "gi");

    // Replace while preserving the original case and accents
    let lastIndex = 0;
    let result = "";
    let match;

    while ((match = regex.exec(originalText)) !== null) {
      const matchedText = match[0];
      result += originalText.substring(lastIndex, match.index);
      result += `<mark class="highlight">${matchedText}</mark>`;
      lastIndex = regex.lastIndex;
    }
    result += originalText.substring(lastIndex);

    element.innerHTML = result;
  }

  function filterItems() {
    const normalizedSearchTerm = normalizeText(searchTerm); // Normalize the search term
    let visibleItems = 0; // To track how many items should be visible

    educationItems.forEach((item) => {
      const itemElement = item as HTMLElement;
      const itemTags = itemElement.dataset.tags?.split(",") || [];
      const titleElement = itemElement.querySelector("h3");
      const descriptionElement = itemElement.querySelector(".description");

      // Extract the title & description and normalize for matching
      const title = titleElement?.textContent || "";
      const description = descriptionElement?.textContent || "";
      const normalizedTitle = normalizeText(title);
      const normalizedDescription = normalizeText(description);

      // Determine if the item matches the active tag or the search term
      const matchesTag = activeTag === "all" || itemTags.includes(activeTag);
      const matchesSearch = !normalizedSearchTerm ||
        normalizedTitle.includes(normalizedSearchTerm) ||
        normalizedDescription.includes(normalizedSearchTerm);

      // The item is visible if it matches both the tag and the search
      const isVisible = matchesTag && matchesSearch;

      // Update visible/hidden styles
      itemElement.style.display = isVisible ? "flex" : "none";

      if (isVisible) {
        visibleItems++;

        // Highlight matching terms if the search term exists
        if (searchTerm && titleElement && descriptionElement) {
          highlightText(titleElement, searchTerm);
          highlightText(descriptionElement, searchTerm);
        } else {
          // Remove existing highlights if no search term is provided
          if (titleElement) titleElement.innerHTML = titleElement.textContent || "";
          if (descriptionElement) descriptionElement.innerHTML = descriptionElement.textContent || "";
        }
      }
    });

    // Show or hide the "No Results" message
    noResultsDiv.style.display = visibleItems === 0 ? "block" : "none";
  }

  function setActiveTag(newTag: string) {
    if (activeTag === newTag) {
      // If the newly clicked tag is the same as the current one, no need to re-filter
      return;
    }

    // Update the active tag
    activeTag = newTag;

    // Update the styling of the tag buttons to reflect the active state
    tagButtons.forEach((btn) => {
      const button = btn as HTMLElement;
      button.classList.toggle("active", button.dataset.tag === newTag);
    });

    // Reapply the filtering logic to show/hide items based on the new tag
    filterItems();
  }

  // Reset the search and tag filters
  function resetSearch() {
    searchInput.value = ""; // Reset search input field
    searchTerm = ""; // Clear search term
    activeTag = "all"; // Reset the active tag to "all"
    clearSearchBtn!.style.display = "none"; // Hide the clear search button
    filterItems(); // Apply filter logic to reset visibility for all items
  }

  // Attach event listeners to tag buttons
  tagButtons.forEach((button) => {
    button.addEventListener("click", () => {
      const buttonElement = button as HTMLButtonElement;
      setActiveTag(buttonElement.dataset.tag || "all");
    });
  });

  // Update existing click handlers
  tagButtons.forEach((button) => {
    button.addEventListener("click", () => {
      const buttonElement = button as HTMLButtonElement;
      setActiveTag(buttonElement.dataset.tag || "all");
    });
  });

  // Add click handler for item tags
  document.addEventListener("click", (e) => {
    const target = e.target as HTMLElement;
    if (target.classList.contains("tag")) {
      const tagText = target.textContent?.trim() || "";
      setActiveTag(tagText);
    }
  });

  // Update reset button click handler
  resetSearchButton?.addEventListener("click", resetSearch);

  // Show/hide clear button based on input content
  searchInput?.addEventListener("input", (e) => {
    clearTimeout(debounceTimeout);

    const hasValue = (e.target as HTMLInputElement).value.length > 0;
    clearSearchBtn!.style.display = hasValue ? "block" : "none";

    debounceTimeout = setTimeout(() => {
      searchTerm = (e.target as HTMLInputElement).value;
      filterItems();
    }, 300);
  });

  // Clear search on button click
  clearSearchBtn?.addEventListener("click", resetSearch);

  let debounceTimeout: number;
</script>
